<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - glTF loader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">

		<style>
			#video {
				position: fixed;
				display: block;
				height: 120px;
			}	

			body {
				background-color: orangered;
			}
		</style>

	</head>

	<body>

		<div id="overlay">
			<div>
				<button id="startButton">Play</button>
			</div>
		</div>
		
		<div id="container"></div>

		<div id="info">
			<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - GLTFLoader + VideoTexture<br />
			Tsunami Simulaci√≥n by
			<a href="https://github.com/josemagr95/" target="_blank" rel="noopener">josemagr95</a><br />
		</div>

		<video id="video" loop muted crossOrigin="anonymous" playsinline style="display:none">
			<source src="textures/tsunami-rotated-mirror-crop.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
		</video>

		<video id="audio" loop crossOrigin="anonymous" playsinline style="display:none">
			<!-- <source src="textures/audio.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'> -->
		</video>

		<script type="module">

			import * as THREE from './build/three.module.js';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
			import { DRACOLoader } from './jsm/loaders/DRACOLoader.js';
			import { RGBELoader } from './jsm/loaders/RGBELoader.js';
			import { RoughnessMipmapper } from './jsm/utils/RoughnessMipmapper.js';

			var container, stats, controls;
			var video, audio, videotexture, material;
			var camera, scene, renderer;

			var startButton = document.getElementById( 'startButton' );
			startButton.addEventListener( 'click', function () {

				init();
				animate();

			}, false );

			function init() {

				var overlay = document.getElementById( 'overlay' );
				overlay.remove();

				

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
				camera.position.set( 7, 4, 7 );

				scene = new THREE.Scene();

				video = document.getElementById( 'video' );
				video.play();
				audio = document.getElementById( 'audio' );
				audio.play();

				videotexture = new THREE.VideoTexture( video );

				videotexture.format = THREE.RGBFormat;
				videotexture.encoding = THREE.sRGBEncoding;
				videotexture.wrapS = videotexture.wrapT = THREE.ClampToEdgeWrapping;
				videotexture.magFilter = THREE.LinearFilter;
				videotexture.mapping = THREE.EquirectangularReflectionMapping;

				console.log(videotexture);

        		var materialVideo = new THREE.MeshBasicMaterial( { map: videotexture } )


				new RGBELoader()
					.setDataType( THREE.UnsignedByteType )
					.setPath( 'textures/equirectangular/' )
					.load( 'spot1Lux.hdr', function ( texture ) {

						var envMap = pmremGenerator.fromEquirectangular( texture ).texture;
						pmremGenerator.dispose();
						
						scene.environment = envMap;

						// model

						var roughnessMipmapper = new RoughnessMipmapper( renderer );

						// Instantiate a loader
						var loader = new GLTFLoader();

						// Optional: Provide a DRACOLoader instance to decode compressed mesh data
						var dracoLoader = new DRACOLoader();
						dracoLoader.setDecoderPath( './js/libs/draco/' );
						loader.setDRACOLoader( dracoLoader );

						// Load a glTF resource
						loader.load(
							// resource URL
							'models/gltf/Tsunami/tsunami_v7.gltf',
							// called when the resource is loaded
							function ( gltf ) {

								gltf.scene.children[0].material = materialVideo;

								scene.add( gltf.scene );

								var mesh = gltf.scene;
								console.log(mesh);

								gltf.animations; // Array<THREE.AnimationClip>
								gltf.scene; // THREE.Group
								gltf.scenes; // Array<THREE.Group>
								gltf.cameras; // Array<THREE.Camera>
								gltf.asset; // Object

							},
							// called while loading is progressing
							function ( xhr ) {

								console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

							},
							// called when loading has errors
							function ( error ) {

								console.log( 'An error happened' );

							}
						);


					} );

				renderer = new THREE.WebGLRenderer( { antialias: true , alpha: true} );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.outputEncoding = THREE.sRGBEncoding;
				container.appendChild( renderer.domElement );

				var pmremGenerator = new THREE.PMREMGenerator( renderer );
				pmremGenerator.compileEquirectangularShader();

				controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 0, - 0.2 );
				controls.enableDamping = false;
				controls.dampingFactor = 0.1;
				controls.rotateSpeed = 0.1;
				controls.zoomSpeed = 0.5;
				controls.panSpeed = 0.1;
				controls.update();

				window.addEventListener( 'resize', onWindowResize, false );


			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				renderer.render( scene, camera );

			}


		</script>

	</body>
</html>
