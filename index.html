<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - glTF loader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">

		<style>
			#video {
				position: fixed;
				display: block;
				height: 120px;
			}	
		</style>

	</head>

	<body>

		<div id="overlay">
			<div>
				<button id="startButton">Play</button>
			</div>
		</div>
		
		<div id="container"></div>

		<div id="info">
			<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - GLTFLoader + VideoTexture<br />
			Tsunami Simulación by
			<a href="https://github.com/josemagr95/" target="_blank" rel="noopener">josemagr95</a><br />
		</div>

		<video id="video" loop muted crossOrigin="anonymous" playsinline style="display:block">
			<source src="textures/tsunami-rotated-mirror.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
		</video>

		<video id="audio" loop crossOrigin="anonymous" playsinline style="display:none">
			<source src="textures/audio.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
		</video>

		<script type="module">

			import * as THREE from './build/three.module.js';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
			import { RGBELoader } from './jsm/loaders/RGBELoader.js';
			import { RoughnessMipmapper } from './jsm/utils/RoughnessMipmapper.js';

			var container, stats, controls;
			var video, audio, videotexture, material;
			var camera, scene, renderer;

			var startButton = document.getElementById( 'startButton' );
			startButton.addEventListener( 'click', function () {

				init();
				animate();

			}, false );

			function init() {

				var overlay = document.getElementById( 'overlay' );
				overlay.remove();

				

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
				camera.position.set( 6, 4, 6 );

				scene = new THREE.Scene();

				video = document.getElementById( 'video' );
				video.play();
				audio = document.getElementById( 'audio' );
				audio.play();
				console.log(video);

				videotexture = new THREE.VideoTexture( video );

				videotexture.format = THREE.RGBFormat;
				videotexture.encoding = THREE.sRGBEncoding;
				videotexture.wrapS = videotexture.wrapT = THREE.ClampToEdgeWrapping;
				videotexture.magFilter = THREE.LinearFilter;
				videotexture.mapping = THREE.EquirectangularReflectionMapping;

				console.log(videotexture);

        		var materialVideo = new THREE.MeshBasicMaterial( { map: videotexture } )


				new RGBELoader()
					.setDataType( THREE.UnsignedByteType )
					.setPath( 'textures/equirectangular/' )
					.load( 'royal_esplanade_1k.hdr', function ( texture ) {

						var envMap = pmremGenerator.fromEquirectangular( texture ).texture;
						pmremGenerator.dispose();
						
						// scene.background = envMap;
						scene.environment = envMap;

						// model

						var roughnessMipmapper = new RoughnessMipmapper( renderer );

						var loader = new GLTFLoader().setPath( 'models/gltf/Tsunami/' );
						loader.load( 'tsunami.gltf', function ( gltf ) {

							gltf.scene.traverse( function ( child ) {

								if ( child.isMesh ) {

									roughnessMipmapper.generateMipmaps( child.material );

								}

							} );

						// AÑADIR OBJETO
							gltf.scene.children[0].material = materialVideo;

							scene.add( gltf.scene);

							var mesh = gltf.scene;
							console.log(mesh);

							roughnessMipmapper.dispose();

						} );

					} );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.outputEncoding = THREE.sRGBEncoding;
				container.appendChild( renderer.domElement );

				var pmremGenerator = new THREE.PMREMGenerator( renderer );
				pmremGenerator.compileEquirectangularShader();

				controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 0, - 0.2 );
				controls.enableDamping = false;
				controls.dampingFactor = 0.1;
				controls.rotateSpeed = 0.1;
				controls.zoomSpeed = 0.5;
				controls.panSpeed = 0.1;
				controls.update();

				window.addEventListener( 'resize', onWindowResize, false );


			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				renderer.render( scene, camera );

			}


		</script>

	</body>
</html>
